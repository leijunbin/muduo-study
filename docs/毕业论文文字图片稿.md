# 毕业论文文字图片稿

## 摘要和关键词

### 中文

### 英文

### 关键词

## 绪论

### 课题背景

### 课题主要研究内容

### 主要工作内容

### 论文结构

## 网络服务器相关技术

### TCP 协议

### HTTP 协议

### Socket

### Linux 系统调用

#### 多路 I/O 复用

I/O复用是一种高效的网络编程技术，可以在单线程或少数线程的情况下处理多个客户端的请求。在网络服务器中，I/O复用技术通常用于监听和处理连接请求，以及处理客户端发送的数据。

传统的网络编程模型是阻塞式的，每个连接需要创建一个线程或进程来处理请求，这种方式在连接数量较少的情况下还可以接受，但是当连接数量增多时，线程或进程的创建和切换会占用大量的 CPU 资源，导致服务器性能下降。

而使用 I/O 复用技术，服务器只需要创建一个线程或进程来监听所有连接请求，并等待这些请求中的任何一个有数据到达。一旦有数据到达，线程或进程就会被唤醒，可以立即处理该请求并返回数据给客户端。这种方式可以有效地降低服务器的 CPU 开销，并且可以处理更多的连接请求。

在 I/O 复用中，常用的技术包括 select、poll、epoll 等，这些技术都是基于操作系统提供的多路复用机制实现的。它们的区别在于实现方式和适用场景不同，但本质上都是通过监听多个文件描述符的可读状态，来实现同时处理多个连接请求的功能。

总的来说，I/O 复用技术是网络服务器中非常重要的一种技术，可以提高服务器的性能和可扩展性，降低服务器的开销和复杂性。

### 1.4.1 select 和 poll 的缺点

select 的缺点:

1. 单个进程能够监视的文件描述符数量存在最大限制，通常是1024（`#define __FD_SETSIZE 1024`）。当然可以更改数量，但由于 select 采用轮询的方式扫描文件描述符，文件描述符数量越多，性能越差;
2. 内核/用户空间内存拷贝问题，select 需要复制大量的句柄数据结构（文件描述符），产生巨大的开销;
3. select 返回的是含有整个句柄的数组，应用程序需要遍历整个数组才能发现哪些句柄发生了事件;
4. select 的触发方式是水平触发，应用程序如果没有完成对一个已经就绪的文件描述符进程IO操作，那么之后每次 select 调用还是会将这些文件描述符通知进程。

相比 select 模型，poll 使用链表保存文件描述符，因此没有了监视文件数量的限制，但其他三个缺点依然存在。

> 以 select 模型为例，假设我们的服务器需要支持100万的并发连接，则在__FD_SETSIZE 为 1024 的情况下，则我们至少需要开辟1k个进程才能实现100万的并发连接。除了进程间上下文切换的时间消耗外，从内核/用户空间大量的句柄结构内存拷贝、数组轮询等，是系统难以承受的。因此，基于select模型的服务器程序，要达到100万级别的并发访问，是一个很难完成的任务。

### 1.4.2 epoll 的优势

epoll的实现机制与select/poll机制完全不同，它们的缺点在epoll上不复存在。

设想一下如下场景：有100万个客户端同时与一个服务器进程保持着TCP连接。而每一时刻，通常只有 几百上千个TCP连接是活跃的(事实上大部分场景都是这种情况)。如何实现这样的高并发？

在select/poll时代，服务器进程每次都把这100万个连接告诉操作系统（从用户态复制句柄数据结构到 内核态），让操作系统内核去查询这些套接字上是否有事件发生，轮询完成后，再将句柄数据复制到用 户态，让服务器应用程序轮询处理已发生的网络事件，这一过程资源消耗较大，因此，select/poll一般 只能处理几千的并发连接。

epoll的设计和实现与select完全不同。epoll通过在Linux内核中申请一个简易的文件系统（文件系统一 般用什么数据结构实现？B+树，磁盘IO消耗低，效率很高）。把原先的select/poll调用分成以下3个部 分：

1. 调用epoll_create()建立一个epoll对象（在epoll文件系统中为这个句柄对象分配资源）
2. 调用epoll_ctl向epoll对象中添加这100万个连接的套接字
3. 调用epoll_wait收集发生的事件的fd资源

如此一来，要实现上面说是的场景，只需要在进程启动时建立一个epoll对象，然后在需要的时候向这 个epoll对象中添加或者删除事件。同时，epoll_wait的效率也非常高，因为调用epoll_wait时，并没有 向操作系统复制这100万个连接的句柄数据，内核也不需要去遍历全部的连接。

epoll_create在内核上创建的eventpoll结构如下：

```c++
struct eventpoll{
....
/*红黑树的根节点，这颗树中存储着所有添加到epoll中的需要监控的事件*/
struct rb_root rbr;
/*双链表中则存放着将要通过epoll_wait返回给用户的满足条件的事件*/
struct list_head rdlist;
....
};
```

### 1.4.3 边缘触发和水平触发

水平触发：当被监控的文件描述符上有可读写事件发生时，会通知用户程序去读写，如果用户一次读写没取完数据，他会一直通知用户，如果这个描述符是用户不关心的，它每次都返回通知用户，则会导致用户对于关心的描述符的处理效率降低。

边缘触发：当被监控的文件描述符上有可读写事件发生时，会通知用户程序去读写，它只会通知用户进程一次，这需要用户一次把内容读取玩，相对于水平触发，效率更高。如果用户一次没有读完数据，再次请求时，不会立即返回，需要等待下一次的新的数据到来时才会返回，这次返回的内容包括上次未取完的数据。

 **muduo 采用的是水平触发** ：

1. 不会丢失数据或消息
   * 应用没有读取完数据，内核会不断上报
2. 低延迟处理
   * 每次读数据只需要一次系统调用，照顾了多个连接的公平性，不会因为某个连接上的数据量过大而影响其他连接处理消息
3. 跨平台处理
   * 像 select 一样可以跨平台使用

#### 操作系统定时时间描述符

### 事件驱动模型

### 线程池技术

## 整体架构设计

### 网络服务器软件需求分析

结合网络服务器软件的现实需求、行业标准、开源社区相关讨论等，一个优秀的网络服务器软件应该满足以下需求[1]：

+ 网络服务器软件能够在操作系统的底层能力支持下，完成以下两个主要任务：
  + 接收并管理来自于不同网络地址，且携带不同网络信息的网络连接，同时为它们分配操作系统资源并协调它们之间的工作；
  + 最大限度地满足各类用户的网络服务要求，及时的响应用户服务请求，为互联网服务用户及时的提供所需要的服务信息，包括但不限于请求的回复报文、静态存储的文件、操作系统的状态等。
+ 网络服务器软件在架构上应该足够抽象，以达成可以利用配置文件、中间件或者插件、软件提供相关配置选项的 API 、甚至于将网络服务器软件作为底层，在上层编写相关代码来实现完成特定网络服务的网络服务器软件等不同方式来适应不同的操作系统、多样的网络协议和网络服务需求、日益增长的网络服务用户数量等任务。
+ 网络服务器软件应该为软件开发者提供友好的编程接口和符合人体工程学的编程范式，同时提供详细且易于理解的使用样例及相关文档。
+ 网络服务器软件在现实中可能出现的各种异常情况下应该通过良好的异常处理机制——包括但不限于日志记录、告警处理、自动恢复等方式来保证网络服务不会被可恢复异常中断，且在发生不可恢复异常时能够提供相关信息以帮助软件开发者快速定位问题，降低不可恢复异常所造成的损失。

### 系统架构设计

基于 3.1 节的需求分析，同时结合了其他优秀的网络服务器软件开源项目的架构（Netpoll[2]、Netty[3]、muduo[4] 等），设计了本网络服务器软件的架构。网络服务器软件整体架构图如图 4-1 所示。网络服务器软件整体架构分为操作系统、公共组件、事件分发、网络协议、用户五层，下面将介绍每一层和相关模块的主要功能。

![img](./image/%E6%9E%B6%E6%9E%84%E5%9B%BE.png)

#### 操作系统

操作系统为计算机硬件提供了抽象和管理，为用户和应用程序提供了接口与服务[5]，但在不同类型的操作系统上相同功能的实现细节、所需的系统调用以及编程上的最佳实践都千差万别，这种差异使得软件的跨平台适配大多都极其繁琐。考虑到网络服务器领域的现实需求和个人能力，本网络服务器软件在架构和实现上都为类 UNIX 系统的适配留下相应接口，但只对 Linux 系统实现完整的网络服务器软件功能。

具体到本服务器软件，类 UNIX 操作系统应当能够为其提供以下接口与服务支持：

+ 网络通信的基础支持，包括网络协议栈、Socket 接口等功能。
+ I/O 多路复用机制。
+ 线程和进程管理机制。
+ 文件系统能够访问并修改磁盘或其他存储设备上的数据。
+ 接收时钟的定时中断，获取时钟的时间信息。

#### 公共组件

公共组件将操作系统提供的接口与服务封装成功能模块，以便于网络服务器软件上层能够忽略底层操作系统的系统调用细节，通过更友好的编程接口来使用操作系统所提供的接口和服务支持，同时为上层应用提供如异步日志等通用功能组件的接口支持。

公共组件各个功能模块的具体功能介绍如下：

+ 网络：对常用网络编程系统接口的封装，包括 Socket、InetAddress、Buffer 部分。

  + Socket 部分是对 Socket 文件描述符及其各种常用操作的封装，如创建 Socket、绑定地址、监听、接受连接等。
  + InetAddress 部分是对网络地址及其相关操作的封装，可以获取本端和对端的 ip 地址和端口信息，也可以传入 ip 地址和端口信息用来设置 Socket 文件描述符所绑定的地址。
  + Buffer 部分是网络服务器软件数据缓冲区的实现。由于网络服务器软件所使用到的网络协议（主要是 TCP 协议）大多是无边界的字节流协议[6]，可能会发生读取或写入数据时不能通过一次系统调用完成的情况，这时就需要缓冲区来承接这部分数据以保证程序不会因此阻塞——例如服务器发送100字节的数据，但使用系统调用后只写入80字节，在缓冲区存在的情况下，服务器软件可以将剩余数据放入缓冲区，并将 Socket 是否可写列入文件描述符监听队列，交出线程控制权，直至 Socket 可写后激活线程并发送缓冲区数据。
+ I/O 复用：对 I/O 复用系统接口的封装，包括 Channel、Poller、EpollPoller 部分。

  + Channel 部分是对文件描述符的封装，每个 Channel 对象与一个文件描述符对应，其中定义了该文件描述符的可监听的事件、事件的回调函数等。
  + Poller 部分抽象了 I/O 多路复用的操作，如注册事件、删除事件等；并提供实现接口，为在其它类 UNIX 系统下实现本网络服务器软件可用的 I/O 多路复用功能给出了符合人体工程学的编程范式。
  + EpollPoller 部分是对 Linux 下 epoll 相关的 I/O 多路复用接口的封装，继承自 Poller 类，补全了接口函数，实现了 Linux 下本网络服务器软件可用的 epoll I/O多路复用功能。
+ Timestamp：本网络服务器软件的微秒级时间戳部分，具有以下功能：

  + 通过操作系统获取当前微秒级时间戳。
  + 可比较时间戳先后顺序、计算时间戳之间的差值、计算某个时间戳在一定时间后的另一个时间戳等。
  + 将时间戳转换成为形如“2023/04/24 23:41:31”格式的时间字符串。
+ Thread：对操作系统线程管理能力的封装，有创建、销毁线程等功能。
+ 定时器：对操作系统接收定时中断能力的封装，且能够在收到定时中断后处理对应事件。包括 Timer、TimerQueue 部分。

  + Timer 部分定义了定时任务的属性以及对其进行读取和修改的函数方法。
  + TimerQueue 部分是定时器队列类，实现了对定时器队列的管理，如添加、删除定时事件等。
+ 异步日志：将代码运行时的重要信息进行保存，方便故障诊断和追踪，包括日志前端和日志后端。

  + 日志前端主要为开发人员提供异步日志接口，能够使其按照等级写入日志并在控制台输出日志信息。包括 Logger、LogStream 部分。
    + Logger 部分为用户提供日志库的接口，能够设置日志等级、控制日志输出流等。
    + LogStream 部分主要提供日志流操作，将用户提供的整型数、浮点数、字符、字符串、字符数组、二进制内存、另一个日志缓冲区，格式化为字符串，并加入当前流的日志缓冲区。
  + 日志后端将前端写下的日志写入文件，放入计算机存储设备中使其持久化。包括 FileUtil、LogFile、AsyncLogging 部分。
    + FileUtil 部分封装操作系统提供的底层的创建、打开文件，写文件，关闭文件等操作接口。
    + LogFile 部分提供对日志文件的操作，包括滚动日志文件、将日志数据写到当前日志文件、刷新日志数据到当前日志文件。
    + AsynccLogging 部分提供缓冲存放多条日志信息，为前端线程提供线程安全的写日志操作；提供专门的后端线程，用于定时或缓冲非空时，将缓冲中日志信息逐个写到磁盘上。

#### 事件分发

事件分发部分实现了事件驱动模型，也是网络服务器软件的核心部分，使其能够在服务多个连接的同时，保持架构和代码的简洁清晰。同时开发人员也可以基于其接口适配其他网络协议，为服务器软件网络协议的适配提供符合直觉的编程范式。包括 EventLoop、EventLoopThread、EventLoopThreadPool 部分。

+ EventLoop 部分是事件循环类，负责接收 Channel 对象上的事件并将其分发到对应的事件处理函数中。
+ EventLoopThread 部分是封装了一个新线程，并在该线程上创建一个 EventLoop 对象，用于处理事件。
+ EventLoopThreadPool 部分是封装了一个线程池，用于创建一组 EventLoopThread 对象，以此提高并发处理能力和操作系统资源利用率。

#### 网络协议

网络协议基于事件分发部分的接口，实现特定网络通信协议的特性，为应用程序提供网络协议支持。开发人员也可以在本部分适配其他的网络协议或特性。本网络服务器软件实现了 TCP 协议和 HTTP 协议。

+ TCP 部分实现对 TCP 连接的管理。包括 TcpConnection、TcpServer、Acceptor 部分。

  + TcpConnection 部分是对一条 TCP 连接的封装，包括读写数据、关闭连接等。
  + TcpServer 部分是对 TCP 服务器的封装，负责监听并处理新的 TCP 连接。
  + Acceptor 部分用于接收来自其他网络地址的 TCP 网络连接并将其分发至线程池中经过分配策略所决定的工作线程。
+ HTTP 部分实现 HTTP 协议中的 GET 和 POST 请求， 实现了静态文件传输和下载的功能。包括 HttpServer、HttpContext、HttpResponse、HttpRequest 部分。

  + HttpServer 部分是对 HTTP 服务器的封装，负责监听并处理新的 HTTP 连接。
  + HttpContext 部分是对 HTTP 报文解析的封装，负责解析收到的 HTTP 报文信息。
  + HttpResponse 部分是对 HTTP 请求类的封装，负责管理 HttpContext 解析完成的报文信息。
  + HttpRequest 部分是对 HTTP 响应类的封装，负责管理服务器响应报文的数据并将其格式化为字符串报文。

#### 用户

用户部分使得使用该系统的各类用户，包括软件开发人员和网络服务的使用者，它们可以通过软件开发人员在这一部分实现的业务代码，从而使网络服务的使用者得到其所需要的服务数据。

### 服务器处理流程

网络服务器软件的本质是处理四个事件[4]，即：

+ 建立连接。
+ 断开连接。
+ 读取网络信息。
+ 发送网络消息。

故网络协议之间细节可能不同，但流程都大致相似，故下文将以 TCP 协议为例介绍本网络服务器软件的网络连接处理流程。图 4-2 为本网络服务器软件在 TCP 协议下的处理流程图。

![img](./image/%E6%B5%81%E7%A8%8B%E5%9B%BE.png)

#### 建立连接

使用 Socket 来创建一个简单的 TCP 服务器时，建立一个连接通常需要四个步骤：

+ 调用 socket 函数建立监听 socket。
+ 调用 bind 函数绑定需要监听的地址和端口。
+ 调用 listen 函数监听端口。
+ 调用 accept 函数返回新建立连接的文件描述符。

而在本网络服务器软件中，也基本遵循了以上步骤：

+ 构造一个事件循环器 EventLoop。
+ 建立对应的业务服务器 TcpServer。在构造 TcpServer 时，会创建 Acceptor 对象，在 Acceptor 对象的构造函数中，会执行 socket 函数和 bind 函数。
+ 然后 main 函数执行 TcpServer 的 TcpServer::start() 方法完成以下两个任务——启动线程池；调用 listen 函数，并将 listen 所监听的文件描述符添加到可读事件的监听队列中。
+ 设置 TcpServer 的对应的回调函数。
+ main 函数会执行 EventLoop::loop() 方法来启动事件循环。在事件循环中，当有连接到来后，会执行 Acceptor 中 handleRead 回调函数，进而调用 TcpServer 中的 newConnection 回调函数，执行 accept 函数并生成对应的文件描述符并将其绑定至一个 TcpConnection 实例中，并注册相应的回调函数。随后将文件描述符分发至线程池中的特定子线程的事件循环中。

#### 读取网络信息

读取网络信息主要有以下两个步骤：

+ 在子线程的事件循环中，当连接中有数据送达时，就会调用 TcpConnection 中的 handleRead 回调函数，将连接送达的数据放入请求数据缓冲区（inputBuffer）中。
+ 调用用户注册的 onMessage 回调函数，执行网络服务的业务逻辑。

#### 发送网络信息

发送网络信息主要有以下个步骤：

+ 在用户注册的 onMessage 回调中会调用 TcpConnection::send() 方法来向用户发送数据。这个方法会调用 TcpConnection::sendInLoop() 。主要做下面几件事：

  + 假如 *outputBuffer_* 为空，则直接向 *connfd* 写数据。

1. 如果向 *connfd* 写的数据没有写完，则记录剩余的字节数。（没写完可能是因为此时socket的TCP缓冲区已经满了）
2. 如果此时 *outputBuffer_* 中的旧数据的个数和未写完字节个数和大于 *highWaterMark_* ，则调用  *highWaterMarkCallback_* 。否则将剩余数据写入 *outputBuffer_* 缓冲区。
3. 如果向 *connfd* 写的数据没有写完，则最后需要为 *connfd* 注册可写事件。

> 注意：直到发送消息的时候，muduo 才会把 socket 的可写事件注册到了 EventLoop 中。在此之前只注册了可读事件。

*connfd* 可写事件对应的回调是  *TcpConnection::handleWrite()* 。主要做两件事：

1. 尽可能将数据从 *outputBuffer_* 中向 *connfd* 中写数据。
2. 如果 *outputBuffer_* 中的数据都写完了，将 *connfd* 的写事件移除，并调用 *writeCompleteCallback_* (用户注册)

> 移除可写事件的原因是：虽然 *outputBuffer_* 中没有数据了，但此时的 *connfd* 一直是处于可写状态的，由于socket 写缓冲区充足，这会导致 *TcpConnection::handleWrite()* 一直触发，这毫无意义。

#### 断开连接

连接的断开分为被动断开和主动断开。主动断开和被动断开的处理方式基本一致，以被动断开为例。

被动断开即客户端断开了连接，server 端需要感知到这个断开的过程，然后进行的相关的处理。

其中感知远程断开这一步是在 Tcp 连接的可读事件处理函数 *TcpConnection::handleRead()* 中进行的：当对 socket 进行 read 操作时，返回值为 0，则说明此时连接已断开。然后调用 *TcpConnection::handleClose()* 函数。主要做四件事：

1. 将 *connfd* 从 *epoll* 中移除。
2. 调用用户的设置的 *connectionCallback_* （*onConnection()* 函数）。
3. 将 *connfd* 对应的 `TcpConnection` 对象从 `TcpServer` 中移除。
4. 关闭  *connfd* 。此步骤是在析构函数中自动触发的，当 `TcpConnection` 对象被移除后，引用计数为 0，对象析构时会调用 close。

## 主要模块的设计与实现

### 公共组件

#### 网络

#### I/O 复用

#### 定时器

#### 异步日志系统

9.错误处理：网络库需要提供有效的错误处理机制，以方便开发者进行调试和错误修复。

在网络库中，错误处理是一个至关重要的部分。良好的错误处理能够帮助开发者快速定位和解决问题，提高程序的可靠性和稳定性。下面是网络库中常见的错误处理技术：

1. 异常处理：在程序中使用异常处理是一种常见的错误处理方式。当程序运行时出现异常，异常处理机制能够捕获并处理异常，给出相应的错误提示信息。异常处理通常用于处理程序中预料之外的错误，如文件读取失败、网络连接中断等。
2. 错误码处理：在程序中使用错误码处理是另一种常见的错误处理方式。错误码是一个数字或字符串，用来标识程序中不同类型的错误。当程序出现错误时，可以通过错误码来判断错误类型，并给出相应的错误提示信息。错误码通常用于处理程序中预料之内的错误，如参数传递错误、调用API失败等。
3. 回调函数处理：在网络库中，通常会提供回调函数，用于处理网络事件。在回调函数中，开发者可以对网络事件进行处理，并给出相应的错误提示信息。回调函数通常用于处理网络事件相关的错误，如网络连接中断、数据包丢失等。
4. 日志处理：在程序中使用日志处理是一种常见的错误处理方式。日志可以记录程序运行中的各种信息，包括错误信息、警告信息、调试信息等。开发者可以通过查看日志来快速定位和解决问题。日志处理通常用于处理程序中难以预料的错误，如内存泄漏、死锁等。

#### Thread

#### Timestamp

### 事件分发

### 网络协议

#### TCP

#### HTTP

## 系统测试

### 测试环境

### 服务器单元测试

### 服务器集成测试

### 系统性能测试

### 测试结果分析

## 总结

### 全文总结

### 未来工作展望

## 致谢

## 参考文献

[1] Nancy J. Yeager; Robert E. McGrath (1996). *Web Server Technology*. ISBN "ISBN (identifier)" 1-55860-376-X. Archived from the original on 20 January 2023. Retrieved 22 January 2021.

[2] [字节跳动在 Go 网络库上的实践](https://www.cloudwego.io/zh/blog/2020/05/24/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E5%9C%A8-go-%E7%BD%91%E7%BB%9C%E5%BA%93%E4%B8%8A%E7%9A%84%E5%AE%9E%E8%B7%B5/)

[3] [Netty Project. Netty Project Community. [2019-01-31].](https://web.archive.org/web/20190130065314/https://netty.io/)

[4] Linux 多线程服务端编程（使用muduo C++网络库）.陈硕 .电子工业出版社 .2021.04

[5] Silberschatz, Abraham; Galvin, Peter Baer; Gagne, Greg. Operating System Concepts. Hoboken, NJ: John Wiley & Sons. 2008. ISBN 978-0-470-12872-5

[6] [RFC 793](https://datatracker.ietf.org/doc/html/rfc793)
