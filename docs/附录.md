# socket 编程基础

## 主机字节序和网络字节序

+ 主机字节序：现代 PC 大多采用小端字节序，因此小段字节序又称之为主机字节序。
+ 网络字节序：网络发送数据总是使用大端字节序，因此大端字节序也称之为网络字节序。

## 主机字节序与网络字节序转换

Linux 提供了如下4个函数来完成主机字节序和网络字节序之间的转换：

```cpp
#include <netinet/in.h>
unsigned long int htonl(unsigned long int hostlong);
unsigned short int htons(unsigned short int hostshort);
unsigned long int ntohl(unsigned long int netlong);
unsigned short int ntohs(unsigned short int netshort);
```

htonl 表示“host to network long”，即将长整型（32 bit）的主机字节序转化为网络字节序数据。这4个函数中，长整型函数通常用来转换 IP 地址，短整型函数用来转换端口号。

## 通用 socket 地址

socket 网络编程接口中表示 socket 地址的是结构体 sockaddr，其定义如下：

```cpp
#include <bits/socket.h>
struct sockaddr {
	sa_family_t sa_family;
	char sa_data[14];
}
```

+ sa_family：是地址类型变量，地址族类型通常与协议族类型对应，常见的协议族和对应地址族如下表所示：

| 协议族   | 地址族   | 描述              |
| -------- | -------- | ----------------- |
| PF_UNIX  | AF_UNIX  | UNIX 本地域协议族 |
| PF_INET  | AF_INET  | TCP/IPv4 协议族   |
| PF_INET6 | AF_INET6 | TCP/IPv6 协议族   |

    宏 PF_* 和 AF_* 都定义在 bit/socket.h 头文件中，且后者与前者有完全相同的值，所以二者通常混用。

+ sa_data 用于存放 socket 地址值，不同协议族的地址值有不同的含义和长度，如下表所示：

| 协议族   | 地址值含义和长度                                                          |
| -------- | ------------------------------------------------------------------------- |
| PF_UNIX  | 文件的路径名，长度可达108字节                                             |
| PF_INET  | 16 bit 端口号和 32 bit IPv4 地址，共6字节                                 |
| PF_INET6 | 16 bit 端口号，32 bit 流标识，128 bit IPv6 地址，32 bit 范围 ID，共26字节 |

    14字节的 sa_data 根本无法完全容纳多数协议族的地址值，因此，Linux 定义了下面的这个新的通用 socket 地址结构体：

```cpp
#include <bits/socket.h>
struct sockaddr_storage {
	sa_family_t sa_family;
	unsigned long int __ss_align;
	char __ss_padding[128 - siseof(__ss_align)];
}
```

## 专用 socket 地址

通用 socket 地址结构体在设置和获取 IP 地址和端口号时需要繁琐的位操作，因此 Linux 为各个协议提供了专用的 socket 地址结构体。

+ UNIX 本地域协议族使用的专用 socket 地址结构体：

```cpp
#include <sys/un.h>
struct socketaddr_un {
	sa_family_t sin_family; // 地址族：AF_UNIX
	char sun_path[108];     // 文件路径名
}
```

+ IPv4 协议族专用 socket 地址结构体：

```cpp
struct sockaddr_in {
	sa_family_t sin_family;      // 地址族：AF_INET
	u_int16_t sin_port;          // 端口号，要用网络字节序表示
	struct in_addr sin_addr;     // IPv4 地址结构体
}
struct in_addr {
	u_int32_t s_addr;            // IPv4 地址，要用网络字节序表示
}
```

+ IPv6 协议族专用 socket 地址结构体：

```cpp
struct sockaddr_in6 {
	sa_family_t sin6_family;      // 地址族：AF_INET6
	u_int16_t sin6_port;          // 端口号，要用网络字节序表示
	u_int32_t sin6_flowinfo;      // 流信息，应设置为0
	struct in6_addr sin6_addr;    // IPv4 地址结构体
	u_int32_t sin6_scope_id;      // scope ID
}
struct in6_addr {
	unsigned char sa_addr[16];    // IPv6 地址，要用网络字节序表示
}
```

所有专用 socket 地址（以及 sockaddr_storage）类型变量在实际使用时都需要转化为通用 socket 地址类型 sockaddr（强制转换即可），因为所有 socket 编程接口使用的地址参数的类型都是 sockaddr。

## IP 地址转换函数


aa

```cpp
int socket(int __domain, int __type, int __protocol) noexcept(true)
```

+ noexcept(true)：等同于 noexcept，表示函数不会引发异常。[文档查看这里。](https://learn.microsoft.com/zh-cn/cpp/cpp/exception-specifications-throw-cpp?view=msvc-170)
+ 函数返回一个文件描述符，来创建 socket 套接字，提供网络通信接口。
+ 函数参数：
  + __domain：IP 地址类型，AF_INET 表示 IPV4，AF_INET6 表示 IPV6。
  + __type：数据传输方式，SOCK_STREAM 表示流格式，面向连接，多用于 TCP；SOCK_DGRAM 表示数据报格式，无连接，多用于UDP。
  + __protocol：协议，0 表示自动推导协议类型，IPPROTO_TCP 和 IPPTOTO_UDP 分别表示 TCP 和 UDP。

```cpp
struct sockaddr_in {
 	short sin_family; // Address family一般来说AF_INET（地址族）PF_INET（协议族）
	unsigned short sin_port; // Port number(必须要采用网络数据格式,普通数字可以用htons()函数转换成网络数据格式的数字)
	struct in_addr sin_addr; // IP address in network byte order（Internet address）
	unsigned char sin_zero[8]; // Same size as struct sockaddr没有实际意义,只是为了跟SOCKADDR结构在内存中对齐*/
};
```
